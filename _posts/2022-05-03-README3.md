---
layout: post
title: "README3"
subtitle: "과제"
date: 2022-05-03 12:20:10 +0900
background: '/PATH_TO_IMAGE'
---

정렬에 대한 정보, 소스 코드는 각 정렬 알고리즘을 제목으로 한 글에 따로 작성해두었습니다.

코드 수행 시간은 원래 배열 출력 + 정렬 + 정렬된 배열 출력에 소요된 시간입니다. 단순히 정렬에 걸리는 시간만을 측정하지 않은 이유는, 정렬만 측정하면 입력 개수가 1024개 까지는 시간이 모두 0으로 나오기 때문에 배열을 출력하는 시간도 포함하였습니다.

가로축의 1은 32, 2는 64, ... 16은 2의 20승이며 세로축은 시간입니다. 

그래프의 계열1은 정렬되었을 때, 계열2는 역정렬되었을 때, 계열 3은 랜덤으로 설정할 때 걸린 시간을 나타내고 있습니다. 랜덤 배열의 소요 시간은 10번을 실행한 후 결과의 평균입니다.

코드 실행 시간을 측정에는 공통으로 아래 코드를 사용하였습니다.

```java
        int[] a=new int[입력 갯수];
	//	Random random=new Random(); 
		int n=a.length;
		for(int i=0; i<n; i++) {  //int i=n-1; i>=0 역순으로 설정할때
	//		a[i]=random.nextInt(); 
			a[i]=i;
			System.out.print(a[i]+" ");
		}
		System.out.print("\n");
		long start = System.currentTimeMillis();
		selection_sort(a);
		long end = System.currentTimeMillis();
		for(int i=0; i<n; i++) {
		System.out.print(a[i]+" ");
		}
		System.out.print("\n");
		System.out.println("실행시간 : " + (end - start)/1000.0);
	}
```

## Quick Sort

![](https://user-images.githubusercontent.com/101469532/166400862-bdc79b0b-08e5-486a-a059-2ad1728088f7.png)

위의 그래프는 Quick Sort의 수행 시간입니다. 

그래프로는 자세히 볼 수 없기 때문에 정확한 시간을 보자면

```
입력갯수 정렬   역정렬   랜덤
32	0.001	0.001	0.001
64	0.002	0.002	0.001
128	0.004	0.002	0.002
256	0.004	0.004	0.003
512	0.009	0.007	0.006
1024	0.011	0.011	0.008
2048	0.016	0.017	0.01
4096	0.028	0.028	0.02
8192	0.049	0.048	0.03
16384	0.077	0.091	0.06
32768	0.173	0.124	0.1
65536	0.313	0.32	0.3
131072	1.021	1.028	1.177
262144	4.238	4.164	5.245
524288	17.249	16.533	21.049
1048576	75.761	74.973	93.866
```

코드 수행 시간은 입력 개수가 4096개 까지는 3가지의 경우가 모두 비슷하다고 볼 수 있습니다. 그리고 입력 개수가 비교적 적을 때에는 정렬/역정렬 되어 있는 경우보다 랜덤 배열에서 속도가 더 빠르지만, 입력이 많아질수록 랜덤과 역정렬/정렬되었을 때의 시간 차가 점점 커지고 있습니다. 

## Heap Sort

![](https://user-images.githubusercontent.com/101469532/166401457-2d5e727f-bea1-49b2-8203-ea1ca2ab0344.png)

위의 그래프는 Heap Sort의 그래프 입니다. 

마찬가지로 정확한 시간을 보자면 

```
입력갯수 정렬   역정렬   랜덤
32	0.0015	0.002	0.002
64	0.002	0.003	0.004
128	0.0035	0.006	0.006
256	0.007	0.008	0.009
512	0.009	0.013	0.012
1024	0.012	0.018	0.02
2048	0.019	0.028	0.02
4096	0.028	0.054	0.03
8192	0.045	0.062	0.08
16384	0.09	0.1	0.1
32768	0.15	0.215	0.3
65536	0.32	0.442	0.9
131072	1.1	1.174	5
262144	8.5	5.411	15
524288	17.2	20.539	53
1048576	73.2	101.407	379.938
```

퀵 정렬과 마찬가지로 힙 정렬도 입력 개수가 2048개 까지는 3가지의 경우 모두 비슷한 수행 시간이 걸리는 것을 볼 수 있습니다. 하지만 입력이 점점 많아질수록 정렬되었을 경우와 역정렬/랜덤인 경우의 시간차가 점점 커지는 것을 볼 수 있습니다. 위에서 보았던 퀵소트와 비교해 보자면 정렬된 경우는 두 정렬 알고리즘에서 비슷한 시간, 역정렬된 경우는 힙 정렬이 살짝 더 오래 걸린다는 것을 볼 수 있습니다. 하지만 랜덤의 경우에는 힙 정렬이 훨씬 느리기 때문에 정렬 알고리즘의 성능은 **Quick > Heap** 이라고 할 수 있습니다. 

## Bubble Sort

![](https://user-images.githubusercontent.com/101469532/166402135-d7ef2e78-c63a-4bfc-9e4e-a034d2422bc3.png)

위의 그래프는 Bubble Sort의 그래프 입니다. 

이 그래프에서 계열3이 16일 때 뚝 떨어지는 모습을 볼 수 있습니다. 이것은 수행 시간이 10분 이상이라서 그래프에 표현하면 다른 값들을 비교하기 어렵기 때문에 0으로 해둔 것입니다.

```
입력갯수 정렬   역정렬   랜덤
32	0.001	0.002	0.002
64	0.003	0.002	0.003
128	0.006	0.005	0.005
256	0.009	0.008	0.009
512	0.015	0.01	0.013
1024	0.023	0.021	0.024
2048	0.035	0.031	0.035
4096	0.051	0.045	0.05
8192	0.069	0.07	0.1
16384	0.127	0.122	0.3
32768	0.423	0.347	1.14
65536	0.787	0.778	5.2
131072	3.073	2.623	29
262144	12.257	11.586	166.978
524288	94.039	48.795	582.891
1048576	201.294	202.878	10분 이상
```

버블 정렬 역시 힙 정렬처럼 입력 개수가 4096개 까지는 수행 시간이 모두 비슷하고, 그 이상이 될수록 역정렬/랜덤 배열의 시간이 급격하게 오래 걸린다는 것을 볼 수 있습니다. 

하지만 힙 정렬/퀵 정렬과 비교해 보자면 정렬된 경우도 위의 두 경우와 달리 매우 오래 걸리는 것을 볼 수 있습니다. 그러므로 버블 소트는 앞에서 본 2개의 정렬 알고리즘보다 대부분의 경우에서 수행 시간이 더 많이 걸린다는 것을 알 수 있기 때문에, 현재까지 정렬 알고리즘의 성능은 **Quick > Heap > Bubble** 라고 할 수 있습니다.

## Insertion Sort

![](https://user-images.githubusercontent.com/101469532/166403097-fa5d843c-5e51-46a0-9844-c77a8c6040b7.png)

위의 그래프는 Insertion Sort의 수행 시간에 대한 그래프 입니다. 

계열3이 16일 때 그래프가 뚝 떨어지는 모습을 볼 수 있습니다. 이것은 수행 시간이 5분 이상이라서 그래프에 표현하면 다른 값들을 비교하기 어렵기 때문에 0으로 해둔 것입니다.

정확한 초를 보자면

```
입력갯수 정렬   역정렬   랜덤
32	0.001	0.001	0.002
64	0.002	0.003	0.004
128	0.006	0.004	0.005
256	0.006	0.006	0.007
512	0.012	0.013	0.013
1024	0.016	0.015	0.02
2048	0.025	0.024	0.032
4096	0.034	0.035	0.05
8192	0.056	0.075	0.1
16384	0.109	0.099	0.2
32768	0.164	0.181	0.7
65536	0.442	0.413	2.5
131072	1.353	1.336	9.5
262144	5.932	6.006	36.811
524288	27.527	30.508	148.246
1048576	96.809	173.338	5분 이상
```

삽입 정렬도 앞에서 본 다른 정렬 알고리즘과 마찬가지로 입력 개수가 2048개 까지는 3가지 경우 모두 비슷한 것으로 볼 수 있습니다. 하지만 입력 개수가 이보다 더 많아질수록 힙/퀵 정렬보다 시간이 더 오래 걸리고, 버블 정렬에 비해서는 빠르기 때문에 정렬 알고리즘의 성능은 **Quick > Heap > Insertion > Bubble** 이라고 할 수 있습니다. 

## Selection Sort

![](https://user-images.githubusercontent.com/101469532/166403640-a2cbb5b2-8f74-4358-a0ec-f0041384caa6.png)

위의 그래프는 Selection Sort의 수행 시간에 대한 그래프 입니다. 

이 또한 2의 20승개의 입력이 랜덤일 때 시간이 5분 이상이 걸렸기 때문에 다른 값의 비교를 위해 0으로 설정해두었습니다. 

```
입력갯수 정렬   역정렬   랜덤
32	0.001	0.001	0.003
64	0.003	0.002	0.003
128	0.003	0.005	0.005
256	0.009	0.005	0.007
512	0.012	0.011	0.014
1024	0.021	0.021	0.025
2048	0.03	0.029	0.035
4096	0.052	0.041	0.048
8192	0.069	0.068	0.08
16384	0.138	0.125	0.2
32768	0.295	0.292	0.5
65536	0.89	0.775	1.76
131072	2.713	2.611	6.9
262144	12.891	10.612	30
524288	59.426	48.666	130
1048576	453.199	485.778	5분 이상
```

선택 정렬도 입력 개수가 2048개 까지는 3가지 경우 모두 비슷한 시간이 걸린다는 것을 알 수 있습니다. 하지만 선택 정렬에서의 특이점은 정렬되었을 경우가 역정렬되었을 경우보다 시간이 많이 걸린다는 것입니다. 
또한 입력 갯수가 많아질수록 다른 정렬들에 비해 랜덤일 때와 정렬/역정렬일 때의 시간 차가 크게 차이 나지 않는다는 것입니다. 그리고 정렬/역정렬 되었을 때 입력이 2의 20승 개 일 때 유난히 오래 걸리는 것을 볼 수 있습니다. 

그러므로 정렬 알고리즘의 성능을 비교해보자면 

* 정렬/역정렬 되었을 때의 입력이 2의 19승 까지 일 때에는

**Quick > Heap > Insertion > Selection > Bubble** 이라고 할 수 있습니다.

* 정렬/역정렬 되었을 때 입력이 2의 20승개 일때는

**Quick > Heap > Insertion > Bubble > Selection** 이라고 할 수 있습니다.

* 입력이 랜덤 배열이 경우에는 

**Quick > Heap > Selection > Insertion > Bubble** 이라고 할 수 있습니다.

## Shell Sort

![](https://user-images.githubusercontent.com/101469532/166403677-d10422eb-dbb9-4b0e-907c-eb3d1d198277.png)

위의 그래프는 Shell Sort의 수행 시간에 대한 그래프 입니다. 

랜덤으로 2의 20승개가 입력될 때 5분 이상의 시간이 걸렸으므로 다른 부분들의 비교를 위해 그래프에는 300으로 표현하였습니다.  

```
입력갯수 정렬   역정렬   랜덤
32	0.002	0.002	0.002
64	0.002	0.002	0.004
128	0.007	0.004	0.005
256	0.008	0.009	0.008
512	0.014	0.011	0.015
1024	0.018	0.018	0.018
2048	0.034	0.024	0.027
4096	0.036	0.034	0.039
8192	0.098	0.052	0.07
16384	0.108	0.105	0.16
32768	0.173	0.183	0.38
65536	0.435	0.426	1.1
131072	1.285	1.244	4
262144	5.967	5.759	15.2
524288	21.817	21.733	59.1
1048576	87.387	182.112	5분 이상
```

이 또한 입력 개수가 4096개 까지는 3가지 경우 모두 비슷한 시간이 걸리는 것을 볼 수 있습니다. 그리고 선택 정렬과 비슷하게 입력 개수가 더 많아져도 다른 정렬 알고리즘과는 달리 랜덤과 정렬/역정렬된 입력의 수행 시간의 차이가 크지 않습니다. 삽입 소트와 비교해 보면 정렬된 경우 입력 개수가 8192개 까지는 Shell 정렬이 더 오래 걸리지만 입력 갯수가 많아질수록 더 빠르다는 것을 알 수 있습니다. 그러므로 Shell 정렬 알고리즘과 Insertion 정렬 알고리즘의 성능은 비슷하다고 할 수 있습니다. 

최종적으로 성능 알고리즘을 비교해보자면 

**Quick > Heap > Shell >= Insertion > Bubble** 이라고 할 수 있습니다.
(Selection Sort는 비교 기준이 애매해서 제외했습니다.)