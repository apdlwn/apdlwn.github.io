---
layout: post
title: "README2"
subtitle: "과제"
date: 2022-04-21 11:10:10 +0900
background: '/PATH_TO_IMAGE'
---

# Ford-Fulkerson Algorithm 

Ford-Fulkerson Algorithm (포드 폴커슨 알고리즘)은 네트워크 유량 알고리즘입니다. 

## 1. Network Flow(네트워크 유량)

그래프의 경로 길이가 아닌 *용량* 의 관점에서 바라보는 시점입니다. 
예를 들어 네트워크를 이용해 아주 큰 파일으 다운로드 한다고 하면, 여기서 주목해야 할 점은 다운로드 하는데 걸리는 시간이 아니라 1초에 몇 MB의 자료를 받을 수 있는가 이다. 이와 같이 각 간선이 용량을 갖는 그래프에 있는 두 노드 사이에서 보낼 수 있는 데이터나 사물의 최대 양을 계산하는 문제를 네트워크 유량 문제(Network Flow)라고 합니다. 

네트워크 유량의 기본적인 알고리즘은 Ford-Fulkerson, dmonds-Karp알고리즘이 있습니다. 두 알고리즘은 기본적으로 brute force algorithm의 특성을 가집니다. 

경로를 찾는 방식은,
Ford-flukerson 은 DFS로 경로를 찾고, Edmonds-Karp 는 BFS로 경로를 찾습니다. 

```
brute force algorithm이란?
:완전 탐색 알고리즘. 즉 가능한 모든 경우의 수를 탐색하면서 요구 조건에 충족되는 결과만을 가져온다. 예외 없이 100%의 확률로 정답만을 출력한다. 
```

유량 네트워크에는 항상 특수한 두 정점인 소스(sorce)와 싱크(sink)가 존재합니다.
소스는 유량이 시작되는 점이고, 싱크는 유량이 도착하는 점입니다. 

#### 네트워크 유량이 가지는 속성

 c(u,v)=정점 u에서 v로 가는 간선의 용량

 f(u,v)=실제 흐르는 유량

**1. 용량 제한**
  * f(u,v) <= c(u,v)

  각 간선의 유량은 간선의 용량을 넘을 수 없습니다.

**2. 유량의 대칭성**
  * f(u,v)=-f(u,v)

  u에서 v로 유량의 흘러올 경우, v의 입장에서는 u로 음수의 유량을 보내는 것입니다. 

**3. 유량의 보존**
  각 정점에서 

  정점에 들어오는 유량의 총 합 == 나가는 유량의 총합

  ex) a-b-c -> f(a,b)=f(b,c)


## 2. Ford-flukerson Algorithm 동작 원리 

이 동작 원리는 Edmonds-Karp Algorithm도 해당됩니다. 

[0] 모든 간선의 유량을 0으로 설정합니다.

[1] sorce에서 sink로 가는 경로를 하나 찾습니다.

-해당 경로에는 반드시 여유 용량이 남아 있어야 합니다. 

[2] 찾아낸 경로에 보낼 수 있는 최대 유량을 찾습니다. 보낼 수 있는 최대 유량은 경로에 남은 잔여 용량의 최소값입니다. 

-경로에서 보낼 수 있는 최대 유량은 각각의 구간에 남은 용량의 최소값입니다.

[3] 찾아낸 경로에 찾아낸 유량울 보냅니다. 

[4] 증가 경로가 더 이상 존재하지 않을 때 까지 1-2-3번을 반복합니다.

![a](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbyT0P0%2FbtroZEe2P8Q%2FVltOTPzdlHv0GZxChctbp1%2Fimg.png)

#### 증가 경로 (argumenting path)

  위의 예시 중 (a)에서 굵은 점선으로 표시된 경로를 이용하면 s 에서 t 로 1만큼 추가 유량을 보낼 수 있습니다.

  (b)에서 한 번 더 굵은 점선으로 표시된 경로를 이용하면 1의 유량을 추가적으로 보낼 수 있습니다.

  이와 같이 유량을 보내는 경로를 증가경로라고 합니다. 

#### 잔여 용량(residul capacity)
   
   경로를 따라 유량을 보낼 수 있으려면 각 간선에 이미 흐르고 있는 유량 외에 추가로 유량을 보낼 수 있는 여유 용량이 있어야 합니다. 

   ```
   잔여 용량(residul capacity) = 간선의 용량 - 유량
   ```

![](https://user-images.githubusercontent.com/101469532/164370809-c49abaa0-ff5c-4898-b915-1519c4413640.jpg)

위의 그래프를 예로 들어 동작 방식을 자세히 설명해 보겠습니다. 

만약 s->A->t(빨간선)를 탐색한 후 s->B->t(파란선)를 탐색하게 된다면 
최대 유량은 2가 되어 올바른 값을 얻을 수 있습니다. 

![](https://user-images.githubusercontent.com/101469532/164370833-e78358b0-3610-4b6f-9d2a-a07f0186ce1e.jpg)

하지만 s->A->B->t(연두선)의 경로를 탐색하게 된다면, 
용량이 부족하기 때문에 s->B로 시작하는 경로를 탐색할 수 없게 됩니다.
그러므로 최대 유량 값으로 1이라는 틀린 값을 얻게 됩니다. 

이러한 문제점을 해결하기 위해서는 유량 상쇄라는 개념을 적용해야합니다. 

#### 유량 상쇄

  유량 상쇄란, 모든 경로에 기존에 존재하는 간선들과 반대되는 방향의 간선을 추가한 뒤, 각 간선으로 유량을 흘려보냈을 때 반대 방향의 간선으로도 음의 유량을 흘려보냄으로써 유량을 상쇄시키는 것입니다. 
 
그러므로 경로를 찾기 전, 반대 방향의 간선의 용량 및 유량의 값을 0으로 설정한 후 s->A->B->t(연두선)을 탐색하게 된다면 

![](https://user-images.githubusercontent.com/101469532/164370843-d569436b-2654-48ae-b4ce-27abc2736272.jpg)

각각 구간 용량의 최소 값이 1이기 때문에 순방향 간선에 1만큼의 유량을 흘려보내주고, 반대 방향의 간선에 이의 음수 값인 -1만큼의 유량을 흘려보내줍니다. 이는 후에 B->A 방향으로(반대 방향으로) 유량을 1만큼 흘려보낼 수 있다는 것을 뜻합니다. 

s->B->A->t 을 탐색하면

![](https://user-images.githubusercontent.com/101469532/164370871-9a0f7d28-d2ac-48d4-a986-7c36a7b4f193.jpg)

각 구간 용량의 최소 값이 1이기 때문에 순방향 간선에 1만큼의 유량을 흘려보내주고, 반대 방향의 간선에 이의 음수 값인 -1만큼의 유량을 흘려보내줍니다. 이런 방식의 동작을 하고 나면 A-B에서는 0만큼의 유량, 즉 A-B사이의 두 간선이 상쇄되었다는 것으로 볼 수 있습니다. 

그러므로 결과는 

![](https://user-images.githubusercontent.com/101469532/164370876-5433e6d2-2384-430b-bf2f-6785f4b4dc86.jpg)

위의 그림과 같이, 최대 유량 값으로 2를 얻을 수 있게 됩니다. 

## 4. 성능 분석

포드 폴커슨 알고리즘은 반목문을 통해 시간 복잡도를 계산하는 것과는 맞지 않습니다.

최대 유량을 f라고 하고, 하나의 증가 경로를 찾는데 방문하는 정점과 간선은 각각 V, E개 입니다. 그러므로 최대 유량을 찾는데 필요한 시간복잡도는 O((V+E)f)입니다. 하지만 보통 정점보다 간선의 갯수가 더 많기 때문에 O(Ef)와 같은 표현도 가능합니다. 

최악의 상황의 경우를 살펴보겠습니다. 

![dddd](https://user-images.githubusercontent.com/101469532/164399813-deb8352e-9c9b-4fb2-a5ad-ac40dda89ab4.png)

만약 이런 그래프가 있다면 s->a->b->t 경로로 10000번, s->b->a->t 경로로 10000번, 총 1~3번의 동작이 20000번 반복이 됩니다. 그러므로 시간복잡도는 O((V+E)f)가 됩니다.