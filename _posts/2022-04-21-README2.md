---
layout: post
title: "README2"
subtitle: "과제"
date: 2022-04-21 11:10:10 +0900
background: '/PATH_TO_IMAGE'
---

# Ford-Fulkerson Algorithm 

Ford-Fulkerson Algorithm (포드 폴커슨 알고리즘)은 네트워크 유량 알고리즘입니다. 

## 1. Network Flow(네트워크 유량)

그래프의 경로 길이가 아닌 *용량* 의 관점에서 바라보는 시점입니다. 
예를 들어 네트워크를 이용해 아주 큰 파일을 다운로드 한다고 하면, 여기서 주목해야 할 점은 다운로드 하는데 걸리는 시간이 아니라 1초에 몇 MB의 자료를 받을 수 있는가 입니다. 이와 같이 각 간선이 용량을 갖는 그래프에 있는 두 노드 사이에서 보낼 수 있는 데이터나 사물의 최대 양을 계산하는 문제를 네트워크 유량 문제(Network Flow) 또는 최대 유량 문제(maximum flow problem)라고 합니다. 

네트워크 유량의 기본적인 알고리즘은 Ford-Fulkerson, Edmonds-Karp알고리즘이 있습니다. 두 알고리즘은 기본적으로 brute force algorithm/그리디 알고리즘의 특성을 가집니다. 

경로를 찾는 방식은,
Ford-flukerson은 DFS로 경로를 찾고, Edmonds-Karp는 BFS로 경로를 찾습니다. 

```
brute force algorithm이란?
:완전 탐색 알고리즘. 즉 가능한 모든 경우의 수를 탐색하면서 요구 조건에 충족되는 결과만을 가져옵니다. 예외 없이 100%의 확률로 정답만을 출력합니다. 
```

유량 네트워크에는 항상 특수한 두 정점인 소스(source)와 싱크(sink)가 존재합니다.
소스는 유량이 시작되는 점이고, 싱크는 유량이 도착하는 점입니다. 

#### 네트워크 유량이 가지는 속성

 c(u,v)=정점 u에서 v로 가는 간선의 용량

 f(u,v)=실제 흐르는 유량

**1. 용량 제한**
  * f(u,v) <= c(u,v)

  각 간선의 유량은 간선의 용량을 넘을 수 없습니다.

**2. 유량의 대칭성**
  * f(u,v)=-f(u,v)

  u에서 v로 유량의 흘러올 경우, v의 입장에서는 u로 음수의 유량을 보내는 것입니다. 

**3. 유량의 보존**

  각 정점에서 

  정점에 들어오는 유량의 총 합 == 나가는 유량의 총합

  ex) a-b-c -> f(a,b)=f(b,c)


### 활용

* Traffic analysis(트래픽 분석)

* Pipe network analysis

* Transportaton networks

* Electrical distribution systems

등..

## 2. Ford-flukerson Algorithm 동작 원리 

이 동작 원리는 Edmonds-Karp Algorithm도 해당됩니다. 

[0] 모든 간선의 유량을 0으로 설정합니다.

[1] source에서 sink로 가는 경로를 하나 찾습니다.

-해당 경로에는 반드시 여유 용량이 남아 있어야 합니다. 

[2] 찾아낸 경로에 보낼 수 있는 최대 유량을 찾습니다. 보낼 수 있는 최대 유량은 경로에 남은 잔여 용량의 최소값입니다. 

-경로에서 보낼 수 있는 최대 유량은 각각의 구간에 남은 용량의 최소값입니다.

[3] 찾아낸 경로에 찾아낸 유량울 보냅니다. 

[4] 증가 경로가 더 이상 존재하지 않을 때 까지 1-2-3번을 반복합니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbyT0P0%2FbtroZEe2P8Q%2FVltOTPzdlHv0GZxChctbp1%2Fimg.png)


#### 증가 경로 (argumenting path)

  위의 예시 중 (a)에서 굵은 점선으로 표시된 경로를 이용하면 s 에서 t 로 1만큼 추가 유량을 보낼 수 있습니다.

  (b)에서 한 번 더 굵은 점선으로 표시된 경로를 이용하면 1의 유량을 추가적으로 보낼 수 있습니다.

  이와 같이 유량을 보내는 경로를 증가경로라고 합니다. 

#### 잔여 용량(residul capacity)
   
   경로를 따라 유량을 보낼 수 있으려면 각 간선에 이미 흐르고 있는 유량 외에 추가로 유량을 보낼 수 있는 여유 용량이 있어야 합니다. 

   ```
   잔여 용량(residul capacity) = 간선의 용량 - 유량
   ```

![](https://user-images.githubusercontent.com/101469532/164370809-c49abaa0-ff5c-4898-b915-1519c4413640.jpg)

위의 그래프를 예로 들어 동작 방식을 자세히 설명해 보겠습니다. 

만약 s->A->t(빨간선)를 탐색한 후 s->B->t(파란선)를 탐색하게 된다면 
최대 유량은 2가 되어 올바른 값을 얻을 수 있습니다. 

![](https://user-images.githubusercontent.com/101469532/164370833-e78358b0-3610-4b6f-9d2a-a07f0186ce1e.jpg)

하지만 s->A->B->t(연두선)의 경로를 탐색하게 된다면, 
용량이 부족하기 때문에 s->B로 시작하는 경로를 탐색할 수 없게 됩니다.
그러므로 최대 유량 값으로 1이라는 틀린 값을 얻게 됩니다. 

이러한 문제점을 해결하기 위해서는 유량 상쇄라는 개념을 적용해야합니다. 

#### 유량 상쇄

  유량 상쇄란, 모든 경로에 기존에 존재하는 간선들과 반대되는 방향의 간선을 추가한 뒤, 각 간선으로 유량을 흘려보냈을 때 반대 방향의 간선으로도 음의 유량을 흘려보냄으로써 유량을 상쇄시키는 것입니다. 
 
그러므로 경로를 찾기 전, 반대 방향의 간선의 용량 및 유량의 값을 0으로 설정한 후 s->A->B->t(연두선)을 탐색하게 된다면 

![](https://user-images.githubusercontent.com/101469532/164370843-d569436b-2654-48ae-b4ce-27abc2736272.jpg)

각각 구간 용량의 최소 값이 1이기 때문에 순방향 간선에 1만큼의 유량을 흘려보내주고, 반대 방향의 간선에 이의 음수 값인 -1만큼의 유량을 흘려보내줍니다. 이는 후에 B->A 방향으로(반대 방향으로) 유량을 1만큼 흘려보낼 수 있다는 것을 뜻합니다. 

s->B->A->t 을 탐색하면

![](https://user-images.githubusercontent.com/101469532/164370871-9a0f7d28-d2ac-48d4-a986-7c36a7b4f193.jpg)

각 구간 용량의 최소 값이 1이기 때문에 순방향 간선에 1만큼의 유량을 흘려보내주고, 반대 방향의 간선에 이의 음수 값인 -1만큼의 유량을 흘려보내줍니다. 이런 방식의 동작을 하고 나면 A-B에서는 0만큼의 유량, 즉 A-B사이의 두 간선이 상쇄되었다는 것으로 볼 수 있습니다. 

그러므로 결과는 

![](https://user-images.githubusercontent.com/101469532/164370876-5433e6d2-2384-430b-bf2f-6785f4b4dc86.jpg)

위의 그림과 같이, 최대 유량 값으로 2를 얻을 수 있게 됩니다. 


이 동작 원리를 매우 매우 간단하게 pseudo code로 써보면
```
while(증가 경로가 있는 동안){
  c=(증가 경로의 잔여 용량)
  for(증가 경로의 간선(u,v)에 대해){
    f(u,v)+=c //정방향 간선 유량에 c를 더한다
    f(v,u)-=c //역방향 간선 유량에 c를 뺀다. 
  }
}
```

## 3. 코드 실행 결과

경로를 설정할 때 시작 노드, 도착 노드, 용량을 엔터로 구분해서 입력해야 합니다.


![](https://user-images.githubusercontent.com/101469532/165758602-282f9983-8e66-47d9-93ce-6c6db0e170dc.jpg)

위에서 본 것과 같이 결과(총유량)는 2가 나오게 됩니다.


## 4. 성능 분석

포드 폴커슨 알고리즘은 반목문을 통해 시간 복잡도를 계산하는 것과는 맞지 않습니다.

최대 유량을 f라고 하고, 하나의 증가 경로를 찾는데 방문하는 정점과 간선은 각각 V, E개 입니다. 그러므로 최대 유량을 찾는데 필요한 시간복잡도는 O((V+E)f)입니다. 하지만 보통 정점보다 간선의 갯수가 더 많기 때문에 O(Ef)와 같은 표현도 가능합니다. 

최악의 상황의 경우를 살펴보겠습니다. 

![](https://user-images.githubusercontent.com/101469532/164399813-deb8352e-9c9b-4fb2-a5ad-ac40dda89ab4.png)

만약 이런 그래프가 있다면 s->a->b->t 경로로 10000번, s->b->a->t 경로로 10000번, 총 1~3번의 동작이 20000번 반복이 됩니다. 그러므로 시간복잡도는 O((V+E)f)가 됩니다.

애드몬드 카프 알고리즘의 시간 복잡도는 O(V*E^2) 입니다.

더 빠른 최대 유량 알고리즘으로는 디닉 알고리즘(Dinic's Algorithm)이 있습니다. 


## 디닉 알고리즘(Dinic's Algorithm)

디닉 알고리즘은 최대 유량을 구하는 알고리즘 중 현재 가장 빠르게 동작하는 알고리즘입니다. 

우선 디닉 알고리즘의 시간 복잡도는 O(V^2*E)로, 애드몬드 카프보다 빠릅니다.

이를 이해하기 위해서는 두 개의 용어가 필요합니다. 

[1] 레벨 그래프(level graph) : 모든 정점에 대해 소스에서부터의 최단 거리를 레벨 값으로 매겨놓은 그래프입니다. source는 레벨이 0, 소스와 인접한 정점들은 1, 소스와 인접한 정점들과 인접한 정점들은 2와 같은 방식으로 레벨을 매깁니다. sink의 레벨은 0이 되며, 여유 용량이 없는 간선들은 사용할 수 없습니다.

**레벨 그래프 형성 조건**
 * 해당 정점은 아직 레벨을 부여받지 않은 정점이어야 합니다. 
 * 여유 용량이 있는 간선들만 사용 가능합니다. 

[2] 차단 유량(blocking flow) : 레벨 그래프에서는 원래의 그래프에서 간선 (u,v)가 존재하더라도, v의 레벨이 u의 레벨보다 1만큼 클 때만 이동 가능합니다. 즉, 레벨 그래프를 형성할 때 레벨 그래프를 형성하는 조건에 맞지 않는 간선들을 제외하는 것이 차단 유량 입니다. 

**알고리즘 짜는 방법**

[1] 레벨 그래프를 만듭니다. 이때 싱크에 도달할 수 없으면 종료합니다. 

[2] 레벨 그래프에서 차단 유량을 찾아 그만큼을 총 유량에 더하고 (1)로 돌아갑니다. 


#### 작동 방식

![](https://user-images.githubusercontent.com/101469532/165795579-d146d14b-57c0-42b4-bd89-3154dc3beb53.png)

(노드 문자=그냥 그래프, 노드 숫자=레벨그래프)

1단계와 같은 그래프를 사용하여 레벨 그래프를 그리면 2단계의 위쪽 그래프처럼 형성됩니다. 1단계에서는 나타났지만 레벨그래프에서는 표현되지 않는 간선을 차단 유량이라고 합니다. 2단계를 거치며 전달된 유량은 14가 됩니다. 전달된 유량을 기존 그래프에 나타내면 2단계 아래 그래프가 됩니다. 

여기서 다시 레벨 그래프를 그리게 되면, 3단계 그림의 두꺼운 화살표를 통해 유량이 흐르게 됩니다. (-6/0 화살표가 나타내는 것은 아까 3->2로 6의 유량을 보낼 때 반대로 2->3으로 -6의 유량을 보냈다는 것입니다.) 두꺼운 화살표를 통해 5만큼의 유량이 추가적으로 흐르게 되어 전달된 총 유량의 양은 14+5=19가 됩니다. 

위의 그림에는 없으나, 또 다시 레벨 그래프를 그려보면 0->1로 1만큼의 유량이 흐르고, 1에서는 유량이 추가적으로 흐르지 못하기 때문에 싱크 노드에 도달할 수 없으므로 프로그램을 종료합니다. 
그러므로 전달된 총 유량, 최대 유량은 19가 됩니다. 


## 최소 컷(Minimum Cut)

최소 컷(Minimum Cut)이란 **두 정점을 분리**하기 위한 최소 비용을 말합니다.
가중치가 있는 그래프의 경우에 최소 컷은 간선을 가장 적게 자를 때 이고, 가중치가 있는 그래프는 간선의 가중치의 합이 가장 적을 때 입니다.
최소 컷 문제를 다룰 때에는 최대 유량 방식으로 접근해야 합니다. 

