---
layout: post
title: "README"
subtitle: "기말"
date: 2022-06-16 13:46:10 +0900
background: '/PATH_TO_IMAGE'
---

## 회귀 분석이란?

* 회귀 분석은 둘 이상의 변수 간의 관계를 보여주는 통계적 방법입니다. 일반적으로 그래프에 표현되고, 종속 변수와 독립 변수 간의 관계를 테스트 합니다. 일반적으로 독립 변수는 종속 변수에 따라 변경됩니다.

* 회귀 계수

선형 모형에서 x와 y의 관계를 수식으로 나타내면 y=ax+b

위의 식에서 a를 회귀 계수(cofficient)이자 선형 회귀 모형의 **모수(parameter)**라고 합니다. 독립 변수 x가 1 증가할 때마다 종속 변수 y는 a만큼 증가합니다. 그래프로 나타내면 회귀 계수는 직선의 기울기가 됩니다. 


* 회귀당 하나의 종속 변수만 있을 수는 없지만, 독립 변수는 여러 개가 있을 수 있습니다. 이를 다중 회귀 라고 합니다.

* 독립 변수는 종속 변수의 완벽한 예측 변수는 아니기 때문에 회귀 분석은 인과 관계를 예측하지 않고 변수 간의 관계만을 예측합니다. 

* 오차항이란, 공식을 신뢰할 수 있는 확실성을 보여주는 수치입니다. 오차항이 클수록 회귀선이 확실하지 않고, 50%이면 변수가 우연보다 낫지 않음을 나타냅니다. 또한 85%이면 독립 변수가 종속 변수에 영향을 미칠 가능성이 상당하다는 것을 나타냅니다. 

* 회귀 분석에서 통계 검정은 

 **1.만들어진 회귀 모형이 유의한가?**
   -주어진 모든 변수들이 어느 정도로 예측 변수의 변화 정도를 예측하는가?

 **2.회귀 계수들이 유의한가?**
   -각 독립 변수의 회귀 계수(b)가 유의한가?

 를 살펴봐야 합니다. 

 * 회귀 분석의 결과로 알 수 있는 것은 **모형적합도**와 **회귀계수** 입니다.

 -모형적합도 : 모형이 데이터에 얼마나 잘 맞는가?

 -회기계수 : 독립 변수의 변화가 종속 변수를 얼마나 변화시키는가?


## 전역 최적화 

* 전역 최적화 기법은 다소 시간이 걸리더라도 전체 탐색 영역에서 가장 좋은 해를 찾는 것을 목표로 합니다. 

유전자 알고리즘(Genetic Algorithm)은 전역 최적화 기법으로 잘 알려져 있습니다.

유전 알고리즘에서 풀고자 하는 문제애 대한 가능한 해들을 정해진 자료 구조로 표현한 다음, 이들을 점차 변형함으로써 점점 더 좋은 해들을 만들어 내는 과정을 거치게 됩니다. 

여기서 해들을 나타내는 자료 구조는 유전자입니다. 이들을 변형함으로써 점점 더 좋은 해들을 만들어 내는 과정을 진화로 표현할 수 있습니다. 

### 유전자 알고리즘

* 유전자 알고리즘은 생물계의 진화를 설명하는 다윈의 적자 생존 이론을 기본 개념으로 한느 계산 모델로서, 존 홀랜드(John Holland)에 의해서 1975년에 개발된 전역 최적화 기법입니다. 

유전자 알고리즘은 일반적으로 선택(selection), 교차(crossover), 돌연변이(mutation)이라는 세가지 종류의 유전자 조작(genetic operation) 과정을 통해 최적해를 탐색해 나갑니다.

* 선택조작 과정은 최종 목표로 하는 적합함수(fitness function)을 최적화시키는 해를 확률적으로 발전시키는 단계로서, 초기집단으로부터 잘전된 집단을 형성시킵니다. 

* 교차조작 과정은 가장 중요한 단계로, 초기 집단으롭터 발전된 집단에 속해있는 배열들 간에 이진수 코드를 교차시키는 역할을 합니다. 

* 돌연변이 조작 과정에서는 각 배열들 자신이 가지고 있는 코드를 무작위로 바꾸게 됨으로써 자손 집단(offspring set)을 형성시킵니다. 

이렇게 생성된 자손 집단에 포함된 배열을 적합 함수에 적용해 우리가 찾고자 하는 최적해를 탐색해 나가게 되는 것입니다. 

## 

지난번에 실행했던 퀵정렬의 입력 갯수와 소요 시간을 주제로 설정하였습니다. 

독립 변수는 입력 개수, 종속 변수는 정렬되었을 경우의 소요 시간으로 설정하였습니다. 

```
입력개수 정렬   역정렬   랜덤
32	0.0015	0.002	0.002
64	0.002	0.003	0.004
128	0.0035	0.006	0.006
256	0.007	0.008	0.009
512	0.009	0.013	0.012
1024	0.012	0.018	0.02
2048	0.019	0.028	0.02
4096	0.028	0.054	0.03
8192	0.045	0.062	0.08
16384	0.09	0.1	0.1
32768	0.15	0.215	0.3
65536	0.32	0.442	0.9
131072	1.1	1.174	5
262144	8.5	5.411	15
524288	17.2	20.539	53
1048576	73.2	101.407	379.938
```
여기서 입력 개수는 너무 크고, 소요 시간은 너무 작기 때문에 

```
입력개수	소요시간
5	1
6	2
7	4
8	4
9	9
10	11
11	16
12	28
13	49
14	77
15	173
16	313

```
위와 같이 입력 개수는 지수만을 사용하였고, 소요 시간는 x100을 해주었습니다. 

![image](https://user-images.githubusercontent.com/101469532/174007109-a7840a01-4560-4092-b575-0a2bf0f2cce9.png)

그래프에서 가로축(+4)는 입력갯수, 세로축은 소요 시간입니다.

그래프를 보면 1차 또는 2차 함수라기 보다는 지수함수에 가까울 것으로 예측되기 때문에 지수 함수를 사용해야 합니다. 

**y=a^x**


#### 알고리즘 구현

* 가정한 함수가 ``y=a^x`` 이므로 모수의 값을 추정하는 방법 말고, a의 값을 랜덤으로 여러 개 생성한 후 그 값들 중에서 가장 최적화된 값을 찾는 유전 알고리즘을 구현해보았습니다.

* 돌연변이는 각 a마다 랜덤으로 0-1사이의 값을 지정하고, 미리 지정해둔 돌연변이 확률 값보다 같거나 작으면 돌연변이가 발생하고(2진수 값에 +1 방식), 이보다 클 경우에는 돌연변이가 발생하지 않는 것으로 걸정하였습니다. 기준을 0.125로 잡은 이유는 돌연변이율(mutation rate)은 일반적으로 (1/모집단크기)-(1/후보해를 이진 표현으로 했을 경우 bit 수)의 범위에서 사용되기 때문에 (1/모집단크기)인 0.125로 지정하였습니다. 

```c
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

double f(double a, double x){
    return pow(a, x);
}
//적합도 계산 함수
//a를 랜덤하게 설정하여 그 값들 중 가장 최적의 값을 찾는 것으로 설정했기 때문에
//랜덤하게 설정된 a의 적합도는 모든 입력(5~16)에 대한 (a^x-원래data)^2 값을 모두 더한 후 나누기 12를 하는 것으로 계산하였습니다.
//적합도가 클수록 좋게? 하기 위해서 역수를 취해주었습니다.(이렇게 안하면 적합도가 작을 수록 좋은? 것입니다)
void calculatefitness(double fitness[], double genedata[], double randoma[]){
    for(int i=0; i<8; i++){
        int a=randoma[i]/10000;
        for(int j=5; j<17; j++){
            fitness[i]+=((f(a, j)-genedata[j])*(f(a, j)-genedata[j]));
        }
        fitness[i]=12/fitness[i];
    }
}
//룰렛 휠의 원반 면적을 적합도에 비례하여 할당시키는 함수
void calculatewheeltable(double wheeltablesize[], double fitness[]){
    double fitnesssum=0;

    for(int i=0; i<8; i++){
        fitnesssum+=fitness[i]; 
    }
    for(int i=0; i<8; i++){
        wheeltablesize[i]=(fitness[i]/fitnesssum)*100;
    }
}
//룰렛 휠
int roulette(double rand_roulette, double wheeltablesize[]){
    for(int i=0; i<8; i++){
        if(wheeltablesize[i]<=rand_roulette)
        rand_roulette-=wheeltablesize[i];
        else
        return i;
    }
}
//선택연산 함수
void selection(double selected[], double wheeltablesize[], double randoma[]){
    for(int i=0; i<8; i++){
        double rand_roulette=rand()%100;
        int n=roulette(rand_roulette, wheeltablesize);
        selected[i]=randoma[n];
        printf("[%d selected] : %f  => %f\n", i+1, selected[i]/10000, wheeltablesize[n]);
    }
}
//교차 연산 함수 
void crossover(double selected[], double selectedbinary[]){
    printf("Crossover\n");
    for(int i=0; i<4; i++){
        char s1[28];
        char s2[28];
        itoa(selected[i], s1, 2);
        selectedbinary[i]=atof(s1);
        itoa(selected[i+4], s2, 2);
        selectedbinary[i+4]=atof(s2);
        int n1,n2;
        for(n1=0; s1[n1]!='\0'; n1++);
        for(n2=0; s2[n2]!='\0'; n2++);
        for(int j=0; j<5; j++){    //하위 5비트를 교환한다. 
            int temp=s1[n1];
            s1[n1]=s2[n2];
            s2[n2]=temp;
            n1--;
            n2--;
        }
        printf("[%d] %f => %f => %s\n", i+1, selected[i], selectedbinary[i], s1);
        printf("[%d] %f => %f => %s\n", i+5, selected[i+4], selectedbinary[i+4], s2);
        selectedbinary[i]=atof(s1);
        selectedbinary[i+4]=atof(s2);
    }
}
//돌연변이 연산 함수
void Mutate(double mutate, double selectedbinary[]){
    printf("benchmark : %f\n", mutate);
    for(int i=0; i<8; i++){
        double n=rand()%1000;
        double randmut=n/1000;
        printf("[%d's mutate] %f : ", i+1, randmut);
        if(randmut<=mutate)  //미리 지정해둔 돌연변이 확률보다 randmut가 크면 변형시킴. 
        selectedbinary[i]+=1;
        printf("%f\n", selectedbinary[i]);
    }
}
void binarytodecimal(double selected[], double selectedbinary[]){
    double weight=1.0;
    for(int i=0; i<8; i++){
        int n=selectedbinary[i];
        while(n > 0){
            if(n%10 != 0){
                selected[i]+=weight;
            }
            n/=10;
            weight*=2;
        }
        printf("[%d] : %f\n", i+1, selected[i]);
    }
}
int main(){
    srand(time(NULL));
    double randoma[8];
    for(int i=0; i<8; i++){
        randoma[i]=rand()%15000;  //a 값 랜덤하게 8개 설정
        printf("[%d] : %f\n", i+1, randoma[i]/10000);    //a 값은 0-1.5이어야 적절하므로 나누기 10000
    }
    double genedata[]={1.0, 2.0,4.0,4.0,9.0,11.0,16.0,28.0,49.0,77.0,173.0,313.0}; //원래 data값
    double fitness[8]={0};  //적합도
    double selected[8]={0};  //선택된 값들 집어넣는 배열
    double wheeltablesize[8]={0}; //원반 면적 
    calculatefitness(fitness, genedata, randoma); //적합도 계산
    calculatewheeltable(wheeltablesize, fitness); //적합도에 비례하는 원반 면적 계산
    selection(selected, wheeltablesize, randoma); //선택 연산
    double selectedbinary[8]={0}; //선택된 값들의 2진수를 저장하는 배열
    crossover(selected, selectedbinary); //교차 연산 후 selectedbinary 배열에 교차 연산된 값들이 저장
    double mutate=0.125;  //돌연변이 확률 지정
    Mutate(mutate, selectedbinary);  //돌연변이 연산 후 selectedbinary 배열에 돌연변이 연산된 값들도 저장
    binarytodecimal(selected, selectedbinary); //2진수로 표현된 a값을 selected 배열에 10진수로 저장
    double fitness2[8];
    calculatefitness(fitness2, genedata, selected); //선택, 교차, 돌연변이 연산을 거친 후 결정된 두 번째 세대 a들의 적합도 계산
    printf("[Result]\n");
    for(int i=0; i<8; i++){
        printf("[%d] %f : %f\n", i+1, selected[i]/10000, 1/fitness[i]);
    }
}
```

#### 결과
![1](https://user-images.githubusercontent.com/101469532/174236769-1b572b43-acd2-4cf8-b55a-22c347f17227.png)
![2](https://user-images.githubusercontent.com/101469532/174236954-88aab9a3-916e-46ff-8cc4-65803132b9c6.png)

* 처음 1-8은 랜덤으로 설정된 a를 출력한 것입니다. 

* 1 selected-8 selected는 선택 연산에서 선택된 값과 그 값의 적합도에 대응하는 룰렛 휠의 원반 면적을 출력하였습니다. 

* Crossover은 우선 a를 이진수로 나타내고, 교차되기 전 값과 교차 이후의 값을 출력하였습니다. 

* mutate는 각 a마다 랜덤으로 설정한 0-1 사이의 값과 변형된 a의 값(변형이 되지 않았을 수도 있습니다.)을 출력하였습니다.

* 이후의 1-8의 값은 이진수로 표현된 a를 10진수로 나타낸 것입니다. 

* Result는 선택, 교차, 돌연변이 연산을 거친 후 최종으로 결정된 a의 값들과 이에 대한 1/적합도를 출력하였습니다. 

Result를 출력하는 과정에서 1/적합도로 출력한 이유는 그냥 적합도 그대로 출력하려고 하면 모두 0이 나와서 역수를 취하였습니다. 그러므로 오른쪽에 있는 숫자들 중 작은 것이 적합도가 높은 것 입니다. 

=> 결과를 보면 1.4~ 들과 1.3~ 의 적합도가 높은 것을 확인할 수 있습니다. 그러므로 a에 적합한 값은 1.3-1.4 인 것을 알 수 있습니다. 또한 처음 랜덤으로 만들어진 8개의 a를 보면 적합도가 높은 1.3-1.4는 4개인 반면에 Result 값들을 보면 5개인 것을 확인할 수 있습니다. 그러므로 두 번째 세대의 **평균적합도가 향상**된 것을 확인할 수 있습니다. 

각 a에 대한 그래프를 살펴보면

![image](https://user-images.githubusercontent.com/101469532/174261412-4f671189-cb17-4aef-8730-bd0bfd77dd7b.png)

다른 값들에 비해 1.3-1.4 사이의 값이 원 데이터 그래프와 가장 유사한 모양임을 확인할 수 있습니다. 

* IF) 미리 지정해둔 돌연변이 기준 확률이 너무 높은 경우

위의 코드에서 mutate를 0.9로 설정하면

![image](https://user-images.githubusercontent.com/101469532/174262744-82f0559a-b037-4932-9599-ff3989b9c7a2.png)

보시다시피 두 번째 세대의 전체에 돌연변이가 발생하는 것을 볼 수 있습니다.

또한 여러번 실행해본 결과, 거의 모든 경우에서 1세대와 비교했을 때 **평균적합도가 저하**된 모습을 확인할 수 있었습니다. 


* IF) 미리 지정해둔 돌연변이 기준 확률이 너무 낮은 경우 

위의 코드에서 mutate를 0.01로 설정하면 

![image](https://user-images.githubusercontent.com/101469532/174262928-d2629197-7422-407b-8475-47a419306546.png)

두 번째 세대에서 돌연변이가 발생하지 않는 모습을 볼 수 있습니다. 

이 경우 또한 기준 확률이 너무 높은 경우와 마찬가지로 거의 모든 경우에서 1세대와 비교했을 때 **평균적합도가 저하**된 모습을 볼 수 있었습니다.